SELECT * FROM EMPLOYEES
SELECT * FROM DEPARTMENTS
SELECT FIRST_NAME, SALARY, DEPARTMENT_ID 
FROM EMPLOYEES

SELECT FIRST_NAME, SALARY, SALARY*0.30, DEPARTMENT_ID 
FROM EMPLOYEES

SELECT FIRST_NAME, SALARY, SALARY*0.30 AS BONUS, DEPARTMENT_ID 
FROM EMPLOYEES

SELECT FIRST_NAME, SALARY, SALARY*0.30 "MONTHLY BONUS", DEPARTMENT_ID 
FROM EMPLOYEES

SELECT FIRST_NAME, SALARY, (SALARY+2000)*0.30, DEPARTMENT_ID 
FROM EMPLOYEES

SELECT LAST_NAME, SALARY, COMMISSION_PCT,12000+SALARY+COMMISSION_PCT AS BONUS
FROM EMPLOYEES

SELECT FIRST_NAME || JOB_ID FROM EMPLOYEES

SELECT FIRST_NAME || ' is a ' || JOB_ID AS EMP_DETAILS FROM EMPLOYEES

SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;

/* SELECT STATEMENT SHOULD BE ALWAYS FOLLOWED BY A FROM STATEMENT */

SELECT 20+88
FROM DUAL

SELECT * FROM DUAL
SELECT SYSDATE FROM DUAL

SELECT ABS(SALARY) FROM EMPLOYEES
SELECT MOD(17,2) FROM DUAL

SELECT LAST_NAME, DEPARTMENT_ID, SALARY, JOB_ID, COMMISSION_PCT
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90

/* WHERE CLAUSE FOLLOWS THE FROM CLAUSE AND CAN BE USED WITH ALL THE COMPARISON OPERATORS*/

SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME = 'King'

SELECT LAST_NAME,HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE = '17-jun-03'

SELECT LAST_NAME,HIRE_DATE, SALARY
FROM EMPLOYEES
WHERE SALARY > 10000 AND SALARY < 12000
AND DEPARTMENT_ID = 80

SELECT LAST_NAME,HIRE_DATE, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SALARY NOT BETWEEN 10000 AND 12000
AND DEPARTMENT_ID = 90

SELECT LAST_NAME,HIRE_DATE, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SALARY > 10000 AND SALARY < 20000
AND DEPARTMENT_ID IN (80,50,90)

SELECT LAST_NAME,HIRE_DATE, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SALARY BETWEEN 10000 AND 12000
OR DEPARTMENT_ID = 90

SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE 'S%'

SELECT LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '__a%'

SELECT FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE
DEPARTMENT_ID IS NULL

SELECT LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID = 'SA_REP'
OR JOB_ID = 'AD_PRES'
AND
SALARY > 15000

SELECT first_name,LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE (JOB_ID = 'SA_REP'
OR JOB_ID = 'AD_PRES')
AND
SALARY > 15000

/* ORDER BY */

SELECT FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT
FROM EMPLOYEES 
ORDER BY SALARY

SELECT FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT
FROM EMPLOYEES 
ORDER BY SALARY DESC

SELECT FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT
FROM EMPLOYEES 
ORDER BY HIRE_DATE

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT
FROM EMPLOYEES 
ORDER BY COMMISSION_PCT DESC

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT
FROM EMPLOYEES 
ORDER BY 4

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, HIRE_DATE, SALARY,COMMISSION_PCT, DEPARTMENT_ID
FROM EMPLOYEES 
ORDER BY DEPARTMENT_ID, SALARY DESC

/* SUBSTITUTION VARIABLES */
/* &, && --> DEFINE, VERIFY */

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, SALARY, &DEPARTMENT_ID
FROM EMPLOYEES 
ORDER BY SALARY DESC

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, SALARY, &&DEPARTMENT_ID
FROM EMPLOYEES 
ORDER BY SALARY DESC

DEFINE DEPARTMENT_ID = 100
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID, SALARY, &DEPARTMENT_ID
FROM EMPLOYEES 
ORDER BY SALARY DESC

UNDEFINE DEPARTMENT_ID

1)	Retrieve a list of DEPARTMENT_NAME values that end with the three letters “ing” and second character is “a” 
from the DEPARTMENTS table

2)	Write a query that extracts the JOB_TITLE, MIN_SALARY, and MAX_SALARY columns, 
as well as an expression called VARIANCE, which is the difference between the MAX_SALARY and MIN_SALARY values, 
for each row. The result should include only JOB_TITLE values that contain either the word “President” or “Manager.” 
Sort the list in descending order based on the VARIANCE expression. If more than one row has the same VARIANCE value, 
then, sort these rows by JOB_TITLE in reverse alphabetic order.

3)	A common computation performed by the Finance department relates to the calculation of taxes levied upon an employee. 
The tax deducted per employee is calculated by obtaining the annual salary for the employee and the current tax rate, 
which may vary from year to year as per the regulations laid from the ministry of finance. 
Write a reusable query for the current tax rate and for an employee_id as input, return the EMPLOYEE_ID, 
FIRST_NAME, SALARY, ANNUAL SALARY,TAX_RATE, and the TAX AMOUNT

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, (SALARY*12) "ANNUAL SALARY",
&&TAX_RATE, (&TAX_RATE*(SALARY*12)) AS "TAX AMOUNT" 
FROM EMPLOYEES

SELECT &&EMPLOYEE_ID, FIRST_NAME, SALARY, (SALARY*12) "ANNUAL SALARY", &&TAX_RATE AS TAX_RATE,
(&TAX_RATE*(SALARY*12)) AS "TAX AMOUNT" 
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_ID

UNDEFINE EMPLOYEE_ID
UNDEFINE TAX_RATE

/* Functions */

/* Characters --> lower, upper, instring, len, trim etc */

SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,LAST_NAME) NAME, JOB_ID, LENGTH(LAST_NAME),
INSTR(last_name,'a') "contains 'a'?"
FROM EMPLOYEES
WHERE SUBSTR(JOB_ID, 4) = 'REP'

SELECT ROUND(108.2345,2)
FROM DUAL

/* DATES */

/* RR format */
/* YY format */

/* 18-June-19
19-May-78 */

/* 0-49 --> CURRENT CENTURY, 50-99 , LAST CENTURY

DD-MM-RR

curr_yr  Given    RR    YY

1998   05-APR-98 1998  1998
1998   05-APR-22 2022  1921

2018   05-APR-18 2018  2018 
2018   05-APR-98 1998  2098 */

15-09-2022

22 --> RR --> 2022
78 --> RR --> 1978
22 --> YY --> 2022
78 --> YY --> 2078

SELECT LAST_NAME, ROUND((SYSDATE-HIRE_DATE)/7,2) "TENURE", HIRE_DATE
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 80

SELECT LAST_NAME, MONTHS_BETWEEN(SYSDATE,HIRE_DATE) "TENURE", HIRE_DATE
FROM EMPLOYEES 

/* TO_CHAR, TO_DATE, TO_NUMBER */
/* NVL, NVL2, COALESCE, NULLIF */
/* CASE, DECODE */

SELECT LAST_NAME, SALARY, COMMISSION_PCT, NVL(COMMISSION_PCT, 0), SALARY+100+COMMISSION_PCT,(SALARY+100+NVL(COMMISSION_PCT,0))
FROM EMPLOYEES

SELECT LAST_NAME, SALARY, COMMISSION_PCT, NVL2(COMMISSION_PCT, 'SAL+COMM','SAL') "INCOME"
FROM EMPLOYEES

/* GROUP FUNCTIONS */

/* AVG, COUNT, SUM, MIN, MAX, DISTINCT */

SELECT ROUND(AVG(SALARY),2), MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES

SELECT DISTINCT(DEPARTMENT_ID) FROM EMPLOYEES
SELECT COUNT(DISTINCT(DEPARTMENT_ID)) FROM EMPLOYEES

/* NULL VALUES ARE IGNORED BY GROUP FUNCTIONS */

SELECT AVG(COMMISSION_PCT) 
FROM EMPLOYEES

SELECT COUNT(EMPLOYEE_ID)
FROM EMPLOYEES

SELECT AVG(NVL(COMMISSION_PCT,0)) 
FROM EMPLOYEES

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2), MAX(SALARY),MIN(SALARY)
FROM EMPLOYEES
GROUP BY (DEPARTMENT_ID)

/* ORDER OF EXECUTION --> FROM, GROUP BY, SELECT */

/* A COLUMN IN GROUP BY CLAUSE NEED NOT BE IN SELECT CLAUSE */

SELECT AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID

/* IN A GROUP FUNCTION THE COLUMNS SELECTED SHOULD BE EITHER A PART OF GROUP BY CLAUSE OR
A GROUP/AGGREGATE FUNCTION */

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2), COUNT(JOB_ID)
FROM EMPLOYEES
GROUP BY (DEPARTMENT_ID)

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2),JOB_ID
FROM EMPLOYEES
GROUP BY (DEPARTMENT_ID, JOB_ID)

/* CANNOT USE WHERE CLAUSE TO RESTRICT GROUP BY FUNCTIONS */

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
WHERE AVG(SALARY)>10000
GROUP BY (DEPARTMENT_ID)

SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2)
FROM EMPLOYEES
GROUP BY (DEPARTMENT_ID)
HAVING AVG(SALARY)>10000

SELECT MAX(AVG(SALARY))
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID

/* JOINS */

/* NATURAL JOINS, OUTER JOINS, CARTESIAN PRODUCT*/
/* USING, ON */

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY
FROM DEPARTMENTS
NATURAL JOIN LOCATIONS

SELECT * FROM DEPARTMENTS
SELECT * FROM LOCATIONS

SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID, CITY
FROM DEPARTMENTS
NATURAL JOIN LOCATIONS
WHERE DEPARTMENT_ID IN (80,50,90)

/* USING CLAUSE */

SELECT EMPLOYEE_ID, LAST_NAME, LOCATION_ID, DEPARTMENT_ID
FROM EMPLOYEES
JOIN
DEPARTMENTS
USING (DEPARTMENT_ID)

/* IF A COLUMN IS PRESENT IN BOTH TABLES AND NOT BEING USED IN THE USING CLAUSE, ALIAS IT */

SELECT EMPLOYEE_ID, LAST_NAME, LOCATION_ID, MANAGER_ID, D.DEPARTMENT_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
USING (MANAGER_ID)

/* DO NOT QUALIFY/ALIAS A COLUMN BEING USED IN THE "USING" CLAUSE */

SELECT LOCATION_ID,L.CITY,D.DEPARTMENT_NAME
FROM LOCATIONS L JOIN DEPARTMENTS D
USING (LOCATION_ID)
WHERE LOCATION_ID = 1400

/* ON */

/* CAN BE USED TO JOIN TABLES WITH DIFFERENT COLUMN NAMES, IF MORE THAN ONE TABLE, COLUMN ALISAING IS REQUIRED */

SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, D.LOCATION_ID
FROM EMPLOYEES E
JOIN
DEPARTMENTS D
ON (E.DEPARTMENT_ID=D.DEPARTMENT_ID)

SELECT EMPLOYEE_ID,CITY,DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN 
DEPARTMENTS D
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.LOCATION_ID
FROM DEPARTMENTS D
JOIN EMPLOYEES E 
ON (E.EMPLOYEE_ID=D.DEPARTMENT_ID)
AND E.MANAGER_ID = 108

SELECT * 
FROM LOCATIONS 
JOIN COUNTRIES
USING (COUNTRY_ID)

SELECT * 
FROM LOCATIONS
JOIN COUNTRIES
ON (LOCATIONS.COUNTRY_ID=COUNTRIES.COUNTRY_ID)

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.LOCATION_ID
FROM DEPARTMENTS D
JOIN EMPLOYEES E 
ON (E.EMPLOYEE_ID=D.DEPARTMENT_ID)

SELECT * FROM EMPLOYEES
SELECT * FROM DEPARTMENTS
SELECT * FROM JOBS


SELECT E.FIRST_NAME, E.SALARY, J.JOB_ID, J.MIN_SALARY, J.MAX_SALARY
FROM EMPLOYEES E
JOIN JOBS J
ON E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY

SELECT LAST_NAME,D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN
DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

SELECT LAST_NAME,D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
RIGHT OUTER JOIN
DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

SELECT LAST_NAME,D.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES E
FULL OUTER JOIN
DEPARTMENTS D
ON (E.DEPARTMENT_ID = D.DEPARTMENT_ID)

/* CROSS JOIN */ 

SELECT LAST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES
CROSS JOIN DEPARTMENTS

/ * SUB QUERIES */

SELECT MAX(SALARY)
FROM EMPLOYEES
WHERE SALARY < (SELECT MAX(SALARY) FROM EMPLOYEES WHERE SALARY <(SELECT MAX(SALARY) FROM EMPLOYEES))

1)The company is planning a recruitment drive and wants to identify the days of the week on which 20 or more staff members were hired. Your report must list the days and the number of employees hired on each of them.

2) Fetch the EMPLOYEE_ID, JOB_ID, DEPARTMENT_ID, LAST_NAME, HIRE_DATE, and END_DATE values for all rows retrieved using a pure natural join. Alias the EMPLOYEES table

3) Produce a report with one column aliased as Managers. with each ach row containing a sentence of the format FIRST_NAME LAST_NAME is manager of the DEPARTMENT_NAME

4) You are required to retrieve the employee’s LAST_NAME, EMPLOYEE_ID, manager’s LAST_NAME, and employee’s DEPARTMENT_ID for the rows with DEPARMENT_ID values of 10, 20, or 30. Alias the EMPLOYEES table as E and the second instance of the EMPLOYEES table as M. Sort the results based on the DEPARTMENT_ID column

5) You are required to retrieve the DEPARTMENT_NAME and DEPARTMENT_ID values for those departments to which no employees are currently assigned.

6) A query that uses subqueries in the column projection list. – Write a query a query to retrieve todays date, No. of departments aliased as dept_count and no of employees in the employees table aliased as Emp_count. The query should report on the current numbers of departments and staff as on date

7) Write a query to identify all the employees who are managers. 
















